//! Bug Report Module for AVA
//!
//! Provides automated bug reporting functionality:
//! - Capture system information
//! - Take screenshots
//! - Generate pre-filled GitHub issue URL
//! - Smart filtering (don't report user-side issues)

use serde::{Deserialize, Serialize};
use sysinfo::{System, SystemExt, CpuExt};

/// Categories of errors for filtering
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub enum ErrorCategory {
    /// Application crash or internal error (reportable)
    ApplicationError,
    /// Backend connection issue (reportable)
    BackendError,
    /// User configuration issue (not reportable by default)
    UserConfiguration,
    /// Missing dependency like Ollama (not reportable)
    MissingDependency,
    /// Network/connectivity issue (not reportable)
    NetworkError,
    /// Unknown error (ask user)
    Unknown,
}

/// Bug report data structure
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BugReport {
    /// Application version
    pub version: String,
    /// Operating system info
    pub os: String,
    /// Error category
    pub category: ErrorCategory,
    /// Error message
    pub error_message: String,
    /// Stack trace if available
    pub stack_trace: Option<String>,
    /// Steps to reproduce (user provided)
    pub steps: Option<String>,
    /// Screenshot path if captured
    pub screenshot_path: Option<String>,
    /// System information
    pub system_info: SystemInfo,
}

/// System information for bug reports
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SystemInfo {
    pub cpu: String,
    pub memory_total_mb: u64,
    pub memory_used_mb: u64,
    pub gpu: Option<String>,
}

impl BugReport {
    /// Create a new bug report with system info auto-populated
    pub fn new(error_message: String, category: ErrorCategory) -> Self {
        let system_info = collect_system_info();

        Self {
            version: env!("CARGO_PKG_VERSION").to_string(),
            os: std::env::consts::OS.to_string(),
            category,
            error_message,
            stack_trace: None,
            steps: None,
            screenshot_path: None,
            system_info,
        }
    }

    /// Check if this error should be reported to GitHub
    pub fn is_reportable(&self) -> bool {
        matches!(
            self.category,
            ErrorCategory::ApplicationError | ErrorCategory::BackendError | ErrorCategory::Unknown
        )
    }

    /// Get reason why error is not reportable
    pub fn non_reportable_reason(&self) -> Option<String> {
        match self.category {
            ErrorCategory::UserConfiguration => {
                Some("This appears to be a configuration issue. Please check your settings.".to_string())
            }
            ErrorCategory::MissingDependency => {
                Some("This error is due to a missing dependency (like Ollama). Please install required dependencies.".to_string())
            }
            ErrorCategory::NetworkError => {
                Some("This appears to be a network connectivity issue. Please check your internet connection.".to_string())
            }
            _ => None,
        }
    }

    /// Generate GitHub issue URL with pre-filled data
    pub fn generate_github_url(&self) -> String {
        let title = format!("[Bug] {}", self.error_message.chars().take(80).collect::<String>());

        let body = format!(
            r#"## Bug Description
{}

## System Information
- **Version**: {}
- **OS**: {}
- **CPU**: {}
- **Memory**: {} / {} MB
- **GPU**: {}

## Stack Trace
```
{}
```

## Steps to Reproduce
{}

---
*This issue was automatically generated by AVA's bug reporter.*"#,
            self.error_message,
            self.version,
            self.os,
            self.system_info.cpu,
            self.system_info.memory_used_mb,
            self.system_info.memory_total_mb,
            self.system_info.gpu.as_deref().unwrap_or("Unknown"),
            self.stack_trace.as_deref().unwrap_or("No stack trace available"),
            self.steps.as_deref().unwrap_or("1. [Please describe what you were doing]\n2. [What happened]\n3. [What you expected]"),
        );

        let encoded_title = urlencoding(&title);
        let encoded_body = urlencoding(&body);

        format!(
            "https://github.com/NAME0x0/AVA/issues/new?title={}&body={}&labels=bug,auto-reported",
            encoded_title,
            encoded_body
        )
    }
}

/// Collect system information
fn collect_system_info() -> SystemInfo {
    let mut sys = System::new_all();
    sys.refresh_all();

    let cpu = sys.cpus().first()
        .map(|c| c.brand().to_string())
        .unwrap_or_else(|| "Unknown CPU".to_string());

    let memory_total_mb = sys.total_memory() / 1024 / 1024;
    let memory_used_mb = sys.used_memory() / 1024 / 1024;

    // GPU detection would require additional platform-specific code
    let gpu = None;

    SystemInfo {
        cpu,
        memory_total_mb,
        memory_used_mb,
        gpu,
    }
}

/// Simple URL encoding for GitHub issue URLs
fn urlencoding(s: &str) -> String {
    let mut result = String::new();
    for c in s.chars() {
        match c {
            'a'..='z' | 'A'..='Z' | '0'..='9' | '-' | '_' | '.' | '~' => {
                result.push(c);
            }
            ' ' => result.push_str("%20"),
            '\n' => result.push_str("%0A"),
            '\r' => {}
            _ => {
                for byte in c.to_string().as_bytes() {
                    result.push_str(&format!("%{:02X}", byte));
                }
            }
        }
    }
    result
}

/// Categorize an error message
pub fn categorize_error(error_msg: &str) -> ErrorCategory {
    let lower = error_msg.to_lowercase();

    // Missing dependency patterns
    if lower.contains("ollama") && (lower.contains("not found") || lower.contains("connection refused")) {
        return ErrorCategory::MissingDependency;
    }
    if lower.contains("python") && lower.contains("not found") {
        return ErrorCategory::MissingDependency;
    }

    // Network patterns
    if lower.contains("connection refused") || lower.contains("timeout") || lower.contains("unreachable") {
        return ErrorCategory::NetworkError;
    }

    // User configuration patterns
    if lower.contains("config") && lower.contains("invalid") {
        return ErrorCategory::UserConfiguration;
    }
    if lower.contains("permission denied") {
        return ErrorCategory::UserConfiguration;
    }

    // Backend errors
    if lower.contains("backend") || lower.contains("api error") {
        return ErrorCategory::BackendError;
    }

    // Application errors (panics, crashes)
    if lower.contains("panic") || lower.contains("crash") || lower.contains("internal error") {
        return ErrorCategory::ApplicationError;
    }

    ErrorCategory::Unknown
}

/// Tauri command to create a bug report
#[tauri::command]
pub fn create_bug_report(error_message: String) -> Result<BugReport, String> {
    let category = categorize_error(&error_message);
    Ok(BugReport::new(error_message, category))
}

/// Tauri command to open bug report in browser
#[tauri::command]
pub fn open_bug_report_url(report: BugReport) -> Result<(), String> {
    let url = report.generate_github_url();
    open::that(&url).map_err(|e| format!("Failed to open browser: {}", e))
}

/// Tauri command to check if error is reportable
#[tauri::command]
pub fn is_error_reportable(error_message: String) -> (bool, Option<String>) {
    let category = categorize_error(&error_message);
    let report = BugReport::new(error_message, category);
    (report.is_reportable(), report.non_reportable_reason())
}
